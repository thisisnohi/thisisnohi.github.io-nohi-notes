(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{275:function(e,n,t){"use strict";t.r(n);var i=t(5),r=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"rsa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rsa","aria-hidden":"true"}},[e._v("#")]),e._v(" RSA")]),e._v(" "),t("h2",{attrs:{id:"加解密加签验签过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加解密加签验签过程","aria-hidden":"true"}},[e._v("#")]),e._v(" 加解密加签验签过程")]),e._v(" "),t("ul",[t("li",[e._v("加密、加签\n"),t("ul",[t("li",[e._v("对方公钥加密数据")]),e._v(" "),t("li",[e._v("本方私钥对加密后数据进行加签，得到加签数据")])])]),e._v(" "),t("li",[e._v("验签、解密过程\n"),t("ul",[t("li",[e._v("获取对方传送加密数据、加签数据")]),e._v(" "),t("li",[e._v("用对方公钥对加签数据进行验签")]),e._v(" "),t("li",[e._v("用本方私钥对加密数据进行解密")])])])]),e._v(" "),t("h2",{attrs:{id:"密钥及格式生成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#密钥及格式生成","aria-hidden":"true"}},[e._v("#")]),e._v(" 密钥及格式生成")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("-- 生成私钥\nopenssl genrsa -out rsa_private_key.pem 1024\n\nopenssl rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout\n\n-- 转换为pkcs8\nopenssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform pem -nocrypt -out rsa_private_key_pkcs8.pem \n\n-- pkcs8 转pkcs1\nopenssl rsa -in pkcs8.pem -out pkcs1.pem\n")])])]),t("ul",[t("li",[e._v("密钥2048，解密时需要设置 最大解密长度=256")])]),e._v(" "),t("h2",{attrs:{id:"demo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#demo","aria-hidden":"true"}},[e._v("#")]),e._v(" DEMO")]),e._v(" "),t("blockquote",[t("p",[e._v("说明：加解密、验签需要双方密钥格式一至，在测试过程中由于密钥保存时，编辑器自动增加回车换行，一直出现解密失败、验签失败情况。")]),e._v(" "),t("p",[e._v("密钥直接使用一行字符串，如果用common-codes包的base64转码，出现多行数据，很容易导致解密、验签失败问题")])]),e._v(" "),t("ul",[t("li",[e._v("加解密工具类")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package nohi.encrpty;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\nimport javax.crypto.Cipher;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class RSAUtils {\n    public static final String SIGN_ALGORITHMS = "SHA1WithRSA";\n    private static String RSA = "RSA";\n    private final static Base64.Decoder DECODER_64 = Base64.getDecoder();\n    private final static Base64.Encoder ENCODER_64 = Base64.getEncoder();\n\n\n    public static KeyPair generateRSAKeyPair() {\n        return generateRSAKeyPair(1024);\n    }\n\n    public static KeyPair generateRSAKeyPair(int keyLength) {\n        try {\n            KeyPairGenerator kpg = KeyPairGenerator.getInstance(RSA);\n            kpg.initialize(keyLength);\n            return kpg.genKeyPair();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static String encryptData(String data, PublicKey publicKey){\n        return ENCODER_64.encodeToString(RSAUtils.encryptData(data.getBytes(), publicKey));\n    }\n\n    public static byte[] encryptData(byte[] data, PublicKey publicKey) {\n        try {\n            byte[] dataReturn = new byte[0];\n            Cipher cipher = Cipher.getInstance(RSA);\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\n            // 加密时超过117字节就报错。为此采用分段加密的办法来加密\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < data.length; i += 100) {\n                byte[] doFinal = cipher.doFinal(ArrayUtils.subarray(data, i,\n                        i + 100));\n                sb.append(new String(doFinal));\n                dataReturn = ArrayUtils.addAll(dataReturn, doFinal);\n            }\n            return dataReturn;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 验证数字签名函数入口\n     *\n     * @param plainBytes 待验签明文字节数组\n     * @param signBytes  待验签签名后字节数组\n     * @param publicKey  验签使用公钥\n     * @return 验签是否通过\n     * @throws Exception\n     */\n    public static boolean verifyDigitalSign(byte[] plainBytes, byte[] signBytes, PublicKey publicKey) throws Exception {\n        boolean isValid = false;\n        try {\n            Signature signature = Signature.getInstance(SIGN_ALGORITHMS);\n            signature.initVerify(publicKey);\n            signature.update(plainBytes);\n            isValid = signature.verify(signBytes);\n            return isValid;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(String.format("验证数字签名时没有[%s]此类算法", SIGN_ALGORITHMS));\n        } catch (InvalidKeyException e) {\n            throw new Exception("验证数字签名时公钥无效");\n        } catch (SignatureException e) {\n            throw new Exception("验证数字签名时出现异常");\n        }\n    }\n\n    public static String rsaSign(byte[] encryptByte, PrivateKey privateKey) {\n        try {\n            Signature signature = Signature.getInstance(SIGN_ALGORITHMS);\n            signature.initSign(privateKey);\n            signature.update(encryptByte);\n            byte[] signed = signature.sign();\n            return (new BASE64Encoder()).encodeBuffer(signed);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String decryptData(String content, PrivateKey privateKey) throws IOException {\n        return new String(RSAUtils.decryptData((new BASE64Decoder()).decodeBuffer(content), privateKey));\n    }\n\n    public static byte[] decryptData(byte[] encryptedData, PrivateKey privateKey) {\n        try {\n            Cipher cipher = Cipher.getInstance(RSA);\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n            // 解密时超过128字节就报错。为此采用分段解密的办法来解密\n            byte[] dataReturn = new byte[0];\n            for (int i = 0; i < encryptedData.length; i += 128) {\n                byte[] doFinal = cipher.doFinal(ArrayUtils.subarray(encryptedData, i,\n                        i + 128));\n                dataReturn = ArrayUtils.addAll(dataReturn, doFinal);\n            }\n\n            return dataReturn;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static boolean doCheck(byte[] encryptByte, byte[] bs, PublicKey publicKey) {\n        try {\n            Signature signature = Signature.getInstance(SIGN_ALGORITHMS);\n            signature.initVerify(publicKey);\n            signature.update(encryptByte);\n            return signature.verify(bs);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    public static PublicKey getPublicKey(byte[] keyBytes) throws NoSuchAlgorithmException,\n            InvalidKeySpecException {\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(RSA);\n        PublicKey publicKey = keyFactory.generatePublic(keySpec);\n        return publicKey;\n    }\n\n    public static PrivateKey getPrivateKey(byte[] keyBytes) throws NoSuchAlgorithmException,\n            InvalidKeySpecException {\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(RSA);\n        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n        return privateKey;\n    }\n\n    public static PublicKey getPublicKey(String modulus, String publicExponent)\n            throws NoSuchAlgorithmException, InvalidKeySpecException {\n        BigInteger bigIntModulus = new BigInteger(modulus);\n        BigInteger bigIntPrivateExponent = new BigInteger(publicExponent);\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(bigIntModulus, bigIntPrivateExponent);\n        KeyFactory keyFactory = KeyFactory.getInstance(RSA);\n        PublicKey publicKey = keyFactory.generatePublic(keySpec);\n        return publicKey;\n    }\n\n    public static PrivateKey getPrivateKey(String modulus, String privateExponent)\n            throws NoSuchAlgorithmException, InvalidKeySpecException {\n        BigInteger bigIntModulus = new BigInteger(modulus);\n        BigInteger bigIntPrivateExponent = new BigInteger(privateExponent);\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(bigIntModulus, bigIntPrivateExponent);\n        KeyFactory keyFactory = KeyFactory.getInstance(RSA);\n        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n        return privateKey;\n    }\n\n    public static PublicKey loadPublicKey(String publicKeyStr) throws Exception {\n        byte[] buffer = (new BASE64Decoder()).decodeBuffer(publicKeyStr);\n        KeyFactory keyFactory = KeyFactory.getInstance(RSA);\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);\n        return keyFactory.generatePublic(keySpec);\n    }\n\n    public static PrivateKey loadPrivateKey(String privateKeyStr) throws Exception {\n        byte[] buffer = (new BASE64Decoder()).decodeBuffer(privateKeyStr);\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(buffer);\n        KeyFactory keyFactory = KeyFactory.getInstance(RSA);\n        return keyFactory.generatePrivate(keySpec);\n    }\n\n    public static PublicKey loadPublicKey(InputStream in) throws Exception {\n        return loadPublicKey(readKey(in));\n    }\n\n    public static PrivateKey loadPrivateKey(InputStream in) throws Exception {\n        return loadPrivateKey(readKey(in));\n    }\n\n    private static String readKey(InputStream in) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(in));\n        String readLine = null;\n        StringBuilder sb = new StringBuilder();\n        while ((readLine = br.readLine()) != null) {\n            if (readLine.charAt(0) == \'-\') {\n                continue;\n            } else {\n                sb.append(readLine);\n                sb.append(\'\\r\');\n            }\n        }\n        System.out.println("1111:\\n" + sb.toString());\n        return sb.toString();\n    }\n\n    /**\n     * 验签\n     *\n     * @param srcData   原始字符串\n     * @param publicKey 公钥\n     * @param sign      签名\n     * @return 是否验签通过\n     */\n    public static boolean verify(String srcData, PublicKey publicKey, String sign) throws Exception {\n        Signature signature = Signature.getInstance(SIGN_ALGORITHMS);\n        signature.initVerify(publicKey);\n        signature.update(srcData.getBytes());\n        return signature.verify(DECODER_64.decode(sign));\n    }\n\n    public static String sign(String data, PrivateKey privateKey) throws Exception {\n        Signature signature = Signature.getInstance(SIGN_ALGORITHMS);\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        return ENCODER_64.encodeToString(signature.sign());\n    }\n}\n\n')])])]),t("ul",[t("li",[t("p",[e._v("测试类")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@Test\n    public void testRsa加密加签() throws Exception {\n        String pubFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/对方系统公钥字符串.txt";\n        String priFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/RSA_PRI.KEY";\n        String loalPubFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/RSA_PUB.KEY";\n\n        String priKey = FileUtils.readStringfromPath(priFile);\n        String pubKey = FileUtils.readStringfromPath(pubFile);\n        String localPub = FileUtils.readStringfromPath(loalPubFile);\n        System.out.println("priKey:" + priKey);\n        System.out.println("pubKey:" + pubKey);\n        System.out.println("localPub:" + localPub);\n\n        System.out.println("==========================");\n\n        pubKey = _2Stri(pubKey);\n        priKey = _2Stri(priKey);\n        localPub = _2Stri(localPub);\n\n        System.out.println("priKey:\\n" + priKey);\n        System.out.println("pubKey:\\n" + pubKey);\n        System.out.println("localPub:\\n" + localPub);\n\n        PrivateKey privateKey = RSAUtils.loadPrivateKey(priKey);\n        PublicKey publicKey = RSAUtils.loadPublicKey(pubKey);\n        PublicKey locaPublicKey = RSAUtils.loadPublicKey(localPub);\n        // 加密\n        String data = "{\\"htbh\\":\\"20200629\\"}";\n        System.out.println(data);\n        String encryptStr = RSAUtils.encryptData(data, publicKey);\n        System.out.println("加密数据:" + encryptStr);\n\n        // RSA签名\n        String sign = RSAUtils.sign2(encryptStr, privateKey);\n        System.out.println("加签:" + sign);\n\n        // 验签\n        boolean result = RSAUtils.verify2(encryptStr, locaPublicKey, sign);\n        System.out.println("验签结果1:" + result);\n    }\n    \n    @Test\n    public void testRsa验签() throws Exception {\n        String pubKeyFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/租赁系统公钥字符串.txt";\n\n        String localSignFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/密文_sign_local.txt";\n        String localDataFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/密文_data_local.txt";\n        String priFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/RSA_PRI.KEY";\n\n        String priKey = FileUtils.readStringfromPath(priFile);\n        String localData = FileUtils.readStringfromPath(localDataFile);\n        String localSign = FileUtils.readStringfromPath(localSignFile);\n        String localPub = FileUtils.readStringfromPath(pubKeyFile);\n        System.out.println("localData:" + localData);\n        System.out.println("localSign:" + localSign);\n        System.out.println("localPub:" + localPub);\n\n        PublicKey locaPublicKey = RSAUtils.loadPublicKey(localPub);\n\n        // 验签\n        boolean result = RSAUtils.verify2(localData, locaPublicKey, localSign);\n        System.out.println("验签结果1:" + result);\n\n        PrivateKey privateKey = RSAUtils.loadPrivateKey(priKey);\n        // 解密\n        String data = RSAUtils.decryptData(localData, privateKey);\n        System.out.println("原文:" + data);\n    }\n\n    @Test\n    public void testRsa验签解密() throws Exception {\n        String pubFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/租赁系统公钥字符串.txt";\n        String priFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/RSA_PRI.KEY";\n\n        String contentFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/密文_data.txt";\n        String signFile = "/Users/nohi/work/workspaces-nohi/nohithink/thinkinjava/src/test/resources/密文_sign.txt";\n\n        String priKey = FileUtils.readStringfromPath(priFile);\n        String pubKey = FileUtils.readStringfromPath(pubFile);\n        String content = FileUtils.readStringfromPath(contentFile);\n        String sign = FileUtils.readStringfromPath(signFile);\n\n//        System.out.println("priKey:" + priKey);\n        System.out.println("pubKey:" + pubKey);\n        System.out.println("content:" + content);\n        System.out.println("sign:" + sign);\n\n        System.out.println("==========================");\n        pubKey = _2Stri(pubKey);\n        priKey = _2Stri(priKey);\n        System.out.println("pubKey:\\n" + pubKey);\n//        System.out.println("priKey:\\n" + priKey);\n\n        System.out.println("pubKey:\\n" + pubKey);\n        System.out.println("priKey:\\n" + priKey);\n        System.out.println("content:\\n" + content);\n        System.out.println("sign:\\n" + sign);\n\n        PrivateKey privateKey = RSAUtils.loadPrivateKey(priKey);\n        PublicKey publicKey = RSAUtils.loadPublicKey(pubKey);\n\n        // 解密\n        String data = RSAUtils.decryptData(content, privateKey);\n        System.out.println("原文:" + data);\n\n        boolean result = RSAUtils.verify2(content, publicKey, sign);\n        System.out.println("验签结果2:" + result);\n    }\n')])])])])])])}],!1,null,null,null);n.default=r.exports}}]);